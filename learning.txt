Building your First Network

  The build your first network (BYFN) scenario provisions a sample Hyperledger Fabric
  network consisting of two organizations, each maintaining two peer nodes, and a “solo” ordering service.

  Install prerequisites
    You will also need to download and install the Hyperledger Fabric Samples. You will notice that
    there are a number of samples included in the fabric-samples repository. We will be using the
    first-network sample. Let’s open that sub-directory now.
      cd first-network
      brew tap hyperledger/fabric
      brew install fabric-tools

    We provide a fully annotated script - byfn.sh - that leverages these Docker images to quickly
    bootstrap a Hyperledger Fabric network comprised of 4 peers representing two different
    organizations, and an orderer node.

    It will also launch a container to run a scripted execution that will join peers to a channel,
    deploy and instantiate chaincode and drive execution of transactions against the deployed
    chaincode.

    If you choose not to supply a channel name, then the script will use a default name of
    mychannel. Execute the following command:

      ./byfn.sh -m generate

    This first step generates all of the certificates and keys for all our various network entities,
    the genesis block used to bootstrap the ordering service, and a collection of configuration
    transactions required to configure a Channel.

    Next, you can bring the network up with the following command:
      ./byfn.sh -m up

    The logs will continue from there. This will launch all of the containers, and then drive a
    complete end-to-end application scenario. Upon successful completion, it should report the in
    your terminal window.

    Finally, let’s bring it all down so we can explore the network setup one step at a time. The
    following will kill your containers, remove the crypto material and four artifacts, and delete
    the chaincode images from your Docker Registry:
      ./byfn.sh -m down

  Crypto Generator
    We will use the cryptogen tool to generate the cryptographic material (x509 certs) for our
    various network entities. These certificates are representative of identities, and they allow
    for sign/verify authentication to take place as our entities communicate and transact.

    How does it work?
      Cryptogen consumes a file - crypto-config.yaml - that contains the network topology and allows
      us to generate a set of certificates and keys for both the Organizations and the components
      that belong to those Organizations.

      Each Organization is provisioned a unique root certificate (ca-cert) that binds specific
      components (peers and orderers) to that Org. By assigning each Organization a unique CA
      certificate, we are mimicking a typical network where a participating Member would use its
      own Certificate Authority.

      Transactions and communications within Hyperledger Fabric are signed by an entity’s private
      key (keystore), and then verified by means of a public key (signcerts).

      You will notice a count variable within this file. We use this to specify the number of peers
      per Organization; in our case there are two peers per Org. We won’t delve into the minutiae of
      x.509 certificates and public key infrastructure right now. If you’re interested, you can
      peruse these topics on your own time.

      Before running the tool, let’s take a quick look at a snippet from the crypto-config.yaml. Pay
      specific attention to the “Name”, “Domain” and “Specs” parameters under the OrdererOrgs
      header:
          OrdererOrgs:
          #---------------------------------------------------------
          # Orderer
          # --------------------------------------------------------
          - Name: Orderer
            Domain: example.com
            CA:
                Country: US
                Province: California
                Locality: San Francisco
            #   OrganizationalUnit: Hyperledger Fabric
            #   StreetAddress: address for org # default nil
            #   PostalCode: postalCode for org # default nil
            # ------------------------------------------------------
            # "Specs" - See PeerOrgs below for complete description
          # -----------------------------------------------------
            Specs:
              - Hostname: orderer
          # -------------------------------------------------------
          # "PeerOrgs" - Definition of organizations managing peer nodes
          # ------------------------------------------------------
          PeerOrgs:
          # -----------------------------------------------------
          # Org1
          # ----------------------------------------------------
          - Name: Org1
            Domain: org1.example.com

      The naming convention for a network entity is as follows
          “{{.Hostname}}.{{.Domain}}”.
      So using our ordering node as a reference point, we are left with an ordering node named
           orderer.example.com
      that is tied to an MSP ID of Orderer.

      This file contains extensive documentation on the definitions and syntax. You can also
      refer to the Membership Service Providers (MSP) documentation for a deeper dive on MSP.

      After we run the cryptogen tool, the generated certificates and keys will be saved to a folder
      titled crypto-config.

  Configuration Transaction Generator

    The configtxgen tool is used to create four configuration artifacts:
      - orderer genesis block,
      - channel configuration transaction,
      - and two anchor peer transactions - one for each Peer Org.

    The orderer block is the Genesis Block for the ordering service, and the channel transaction
    file is broadcast to the orderer at Channel creation time. The anchor peer transactions, as the
    name might suggest, specify each Org’s Anchor Peer on this channel.

    How does it work?

      Configtxgen consumes a file - configtx.yaml - that contains the definitions for the sample
      network. There are three members - one Orderer Org (OrdererOrg) and two Peer Orgs (Org1 &
      Org2) each managing and maintaining two peer nodes.

      This file also specifies a consortium - SampleConsortium - consisting of our two Peer Orgs.
      Pay specific attention to the “Profiles” section at the top of this file. You will notice that
      we have two unique headers. One for the orderer genesis block - TwoOrgsOrdererGenesis - and
      one for our channel - TwoOrgsChannel.

      These headers are important, as we will pass them in as arguments when we create our artifacts.

      Note
      Notice that our SampleConsortium is defined in the system-level profile and then referenced by
      our channel-level profile. Channels exist within the purview of a consortium, and all
      consortia must be defined in the scope of the network at large.

      This file also contains two additional specifications that are worth noting. Firstly, we
      specify the anchor peers for each Peer Org (peer0.org1.example.com & peer0.org2.example.com).
      Secondly, we point to the location of the MSP directory for each member, in turn allowing us
      to store the root certificates for each Org in the orderer genesis block. This is a critical
      concept. Now any network entity communicating with the ordering service can have its digital
      signature verified.

  Run the tools

  You can manually generate the certificates/keys and the various configuration artifacts using the
  configtxgen and cryptogen commands. Alternately, you could try to adapt the byfn.sh script to
  accomplish your objectives.

  Manually generate the artifacts
    You can refer to the generateCerts function in the byfn.sh script for the commands necessary to
    generate the certificates that will be used for your network configuration as defined in the
    crypto-config.yaml file. However, for the sake of convenience, we will also provide a reference
    here.

    First let’s run the cryptogen tool:
      cryptogen generate --config=./crypto-config.yaml

    You will likely see the following warning. It’s innocuous, ignore it:
      [bccsp] GetDefault -> WARN 001 Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.

    First, we need to set an environment variable to specify where configtxgen should look for the
    configtx.yaml configuration file:
      export FABRIC_CFG_PATH=$PWD

    Then, we’ll invoke the configtxgen tool which will create the orderer genesis block:
      configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block

    You can ignore the log warnings regarding intermediate certificates, certificate revocation
    lists (crls) and MSP configurations. We are not using any of those in this sample network.

  Create a Channel Configuration Transaction
    Next, we need to create the channel transaction artifact. Be sure to replace $CHANNEL_NAME or
    set CHANNEL_NAME as an environment variable that can be used throughout these instructions:
      export CHANNEL_NAME=mychannel
      configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME

    Next, we will define the anchor peer for Org1 on the channel that we are constructing. Again, be
    sure to replace $CHANNEL_NAME or set the environment variable for the following commands:
      export CHANNEL_NAME=mychannel
      configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP

    Now, we will define the anchor peer for Org2 on the same channel:
      configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP

  Start the network
    We will leverage a docker-compose script to spin up our network. The docker-compose file
    references the images that we have previously downloaded, and bootstraps the orderer with our
    previously generated genesis.block.
      working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
      # command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT'
      volumes

    If left uncommented, that script will exercise all of the CLI commands when the network is
    started, as we describe in the What’s happening behind the scenes? section. However, we want to
    go through the commands manually in order to expose the syntax and functionality of each call.

    Pass in a moderately high value for the TIMEOUT variable (specified in seconds); otherwise the
    CLI container, by default, will exit after 60 seconds.

    Start your network:
      CHANNEL_NAME=$CHANNEL_NAME TIMEOUT=<pick_a_value> docker-compose -f docker-compose-cli.yaml up -d

    If you want to see the realtime logs for your network, then do not supply the -d flag. If you
    let the logs stream, then you will need to open a second terminal to execute the CLI calls.

    Environment variables
      For the following CLI commands against peer0.org1.example.com to work, we need to preface our
      commands with the four environment variables given below. These variables for
      peer0.org1.example.com are baked into the CLI container, therefore we can operate without
      passing them. HOWEVER, if you want to send calls to other peers or the orderer, then you will
      need to provide these values accordingly. Inspect the docker-compose-base.yaml for the specific
      paths:
        # Environment variables for PEER0
        CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
        CORE_PEER_ADDRESS=peer0.org1.example.com:7051
        CORE_PEER_LOCALMSPID="Org1MSP"
        CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

    Create & Join Channel

      Recall that we created the channel configuration transaction using the configtxgen tool in the
      Create a Channel Configuration Transaction section, above. You can repeat that process to
      create additional channel configuration transactions, using the same or different profiles in
      the configtx.yaml that you pass to the configtxgen tool. Then you can repeat the process
      defined in this section to establish those other channels in your network.

      We will enter the CLI container using the docker exec command:
        docker exec -it cli bash

      If successful you should see the following:
        root@0d78bb69300d:/opt/gopath/src/github.com/hyperledger/fabric/peer#

      Next, we are going to pass in the generated channel configuration transaction artifact that we
      created in the Create a Channel Configuration Transaction section (we called it channel.tx) to
      the orderer as part of the create channel request.

      We specify our channel name with the -c flag and our channel configuration transaction with
      the -f flag. In this case it is channel.tx, however you can mount your own configuration
      transaction with a different name.
        export CHANNEL_NAME=mychannel

      # the channel.tx file is mounted in the channel-artifacts directory within your CLI container
      # as a result, we pass the full path for the file
      # we also pass the path for the orderer ca-cert in order to verify the TLS handshake
      # be sure to replace the $CHANNEL_NAME variable appropriately
      peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

      This command returns a genesis block - <channel-ID.block> - which we will use to join the
      channel. It contains the configuration information specified in channel.tx.

      Now let’s join peer0.org1.example.com to the channel.

        # By default, this joins ``peer0.org1.example.com`` only
        # the <channel-ID.block> was returned by the previous command
        peer channel join -b <channel-ID.block>

      You can make other peers join the channel as necessary by making appropriate changes in the
      four environment variables we used in the peerenvvars section, above.


      Install & Instantiate Chaincode

        We will utilize a simple existing chaincode. To learn how to write your own chaincode, see
        the Chaincode for Developers tutorial.

        Applications interact with the blockchain ledger through chaincode. As such we need to
        install the chaincode on every peer that will execute and endorse our transactions, and then
        instantiate the chaincode on the channel.

        First, install the sample Go code onto one of the four peer nodes. This command places the
        source code onto our peer’s filesystem.

          peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02

        Next, instantiate the chaincode on the channel. This will initialize the chaincode on the
        channel, set the endorsement policy for the chaincode, and launch a chaincode container for
        the targeted peer. Take note of the -P argument. This is our policy where we specify the
        required level of endorsement for a transaction against this chaincode to be validated.

        In the command below you’ll notice that we specify our policy as
          -P "OR ('Org0MSP.member','Org1MSP.member')"
        This means that we need “endorsement” from a peer belonging to Org1 OR Org2 (i.e. only one
        endorsement). If we changed the syntax to AND then we would need two endorsements.

          # be sure to replace the $CHANNEL_NAME environment variable
          # if you did not install your chaincode with a name of mycc, then modify that argument as well
          peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

        See the endorsement policies documentation for more details on policy implementation.

      Query
        Let’s query for the value of a to make sure the chaincode was properly instantiated and the
        state DB was populated. The syntax for query is as follows:

          # be sure to set the -C and -n flags appropriately
          peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'

      Invoke
        Now let’s move 10 from a to b. This transaction will cut a new block and update the state
        DB. The syntax for invoke is as follows:

          # be sure to set the -C and -n flags appropriately
          peer chaincode invoke -o orderer.example.com:7050  --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}'

      Query
        Let’s confirm that our previous invocation executed properly. We initialized the key a with
        a value of 100 and just removed 10 with our previous invocation. Therefore, a query against
        a should reveal 90. The syntax for query is as follows.

          # be sure to set the -C and -n flags appropriately
          peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'

        We should see the following:
          Query Result: 90

        Feel free to start over and manipulate the key value pairs and subsequent invocations.

      What’s happening behind the scenes?

        These steps describe the scenario in which script.sh is not commented out in the
        docker-compose-cli.yaml file. Clean your network with ./byfn.sh -m down and ensure this
        command is active. Then use the same docker-compose prompt to launch your network again.

        - A script - script.sh - is baked inside the CLI container. The script drives the
            createChannel command against the supplied channel name and uses the channel.tx file for
            channel configuration.
        - The output of createChannel is a genesis block - <your_channel_name>.block - which gets '
            stored on the peers’ file systems and contains the channel configuration specified from
            channel.tx.
        - The joinChannel command is exercised for all four peers, which takes as input the
            previously generated genesis block. This command instructs the peers to join
            <your_channel_name> and create a chain starting with <your_channel_name>.block.
        - Now we have a channel consisting of four peers, and two organizations. This is our
            TwoOrgsChannel profile.
        - peer0.org1.example.com and peer1.org1.example.com belong to Org1; peer0.org2.example.com
            and peer1.org2.example.com belong to Org2
        - These relationships are defined through the crypto-config.yaml and the MSP path is
            specified in our docker compose.
        - The anchor peers for Org1MSP (peer0.org1.example.com) and Org2MSP (peer0.org2.example.com)
            are then updated. We do this by passing the Org1MSPanchors.tx and Org2MSPanchors.tx
            artifacts to the ordering service along with the name of our channel.
        - A chaincode - chaincode_example02 - is installed on peer0.org1.example.com and
            peer0.org2.example.com
        - The chaincode is then “instantiated” on peer0.org2.example.com. Instantiation adds the
            chaincode to the channel, starts the container for the target peer, and initializes the
            key value pairs associated with the chaincode. The initial values for this example are
            [“a”,”100” “b”,”200”]. This “instantiation” results in a container by the name of
            dev-peer0.org2.example.com-mycc-1.0 starting.
        - The instantiation also passes in an argument for the endorsement policy. The policy is
            defined as -P "OR    ('Org1MSP.member','Org2MSP.member')", meaning that any transaction
            must be endorsed by a peer tied to Org1 or Org2.
        - A query against the value of “a” is issued to peer0.org1.example.com. The chaincode was
            previously installed on peer0.org1.example.com, so this will start a container for Org1
            peer0 by the name of dev-peer0.org1.example.com-mycc-1.0. The result of the query is
            also returned. No write operations have occurred, so a query against “a” will still
            return a value of “100”.
        - An invoke is sent to peer0.org1.example.com to move “10” from “a” to “b”
        - The chaincode is then installed on peer1.org2.example.com
        - A query is sent to peer1.org2.example.com for the value of “a”. This starts a third
            chaincode container by the name of dev-peer1.org2.example.com-mycc-1.0. A value of 90 is returned, correctly reflecting the previous transaction during which the value for key “a” was modified by 10.

      What does this demonstrate?
        Chaincode MUST be installed on a peer in order for it to successfully perform read/write
        operations against the ledger.

        Furthermore, a chaincode container is not started for a peer until an init or traditional
        transaction - read/write - is performed against that chaincode (e.g. query for the value of
        “a”). The transaction causes the container to start.

        Also, all peers in a channel maintain an exact copy of the ledger which comprises the
        blockchain to store the immutable, sequenced record in blocks, as well as a state database
        to maintain a snapshot of the current state. This includes those peers that do not have
        chaincode installed on them (like peer1.org1.example.com in the above example) .

        Finally, the chaincode is accessible after it is installed (like peer1.org2.example.com in
        the above example) because it has already been instantiated.

      How do I see these transactions?
        Check the logs for the CLI Docker container.

          docker logs -f cli

        You should see the following output:

          2017-05-16 17:08:01.366 UTC [msp] GetLocalMSP -> DEBU 004 Returning existing local MSP
          2017-05-16 17:08:01.366 UTC [msp] GetDefaultSigningIdentity -> DEBU 005 Obtaining default signing identity
          2017-05-16 17:08:01.366 UTC [msp/identity] Sign -> DEBU 006 Sign: plaintext: 0AB1070A6708031A0C08F1E3ECC80510...6D7963631A0A0A0571756572790A0161
          2017-05-16 17:08:01.367 UTC [msp/identity] Sign -> DEBU 007 Sign: digest: E61DB37F4E8B0D32C9FE10E3936BA9B8CD278FAA1F3320B08712164248285C54
          Query Result: 90
          2017-05-16 17:08:15.158 UTC [main] main -> INFO 008 Exiting.....
          ===================== Query on PEER3 on channel 'mychannel' is successful =====================

          ===================== All GOOD, BYFN execution completed =====================


      How can I see the chaincode logs?
        Inspect the individual chaincode containers to see the separate transactions executed against each container. Here is the combined output from each container:
          $ docker logs dev-peer0.org2.example.com-mycc-1.0
          04:30:45.947 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
          ex02 Init
          Aval = 100, Bval = 200

          $ docker logs dev-peer0.org1.example.com-mycc-1.0
          04:31:10.569 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
          ex02 Invoke
          Query Response:{"Name":"a","Amount":"100"}
          ex02 Invoke
          Aval = 90, Bval = 210

          $ docker logs dev-peer1.org2.example.com-mycc-1.0
          04:31:30.420 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
          ex02 Invoke
          Query Response:{"Name":"a","Amount":"90"}


      Understanding the Docker Compose topology
        The BYFN sample offers us two flavors of Docker Compose files, both of which are extended
        from the docker-compose-base.yaml (located in the base folder).

        Our first flavor, docker-compose-cli.yaml, provides us with a CLI container, along with an
        orderer, four peers. We use this file for the entirety of the instructions on this page.

        The second flavor, docker-compose-e2e.yaml, is constructed to run end-to-end tests using 
        the Node.js SDK. Aside from functioning with the SDK, its primary differentiation is that 
        there are containers for the fabric-ca servers. As a result, we are able to send REST calls
        to the organizational CAs for user registration and enrollment.

