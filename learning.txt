Read-Write set semantics

  This documents discusses the details of the current implementation about the semantics of
  read-write sets.

  Transaction simulation and read-write set

    During simulation of a transaction at an endorser, a read-write set is prepared for the
    transaction.

    The read set contains a list of unique keys and their committed versions that the
    transaction reads during simulation. The write set contains a list of unique keys
    (though there can be overlap with the keys present in the read set) and their new values
    that the transaction writes.

    A delete marker is set (in the place of new value) for the key if the update performed by
    the transaction is to delete the key.

    Further, if the transaction writes a value multiple times for a key, only the last written
    value is retained. Also, if a transaction reads a value for a key, the value in the
    committed state is returned even if the transaction has updated the value for the key
    before issuing the read. In another words, Read-your-writes semantics are not supported.

    As noted earlier, the versions of the keys are recorded only in the read set; the write
    set just contains the list of unique keys and their latest values set by the transaction.

    Additionally, if the transaction performs a range query during simulation, the range query
    as well as its results will be added to the read-write set as query-info.

  Transaction validation and updating world state using read-write set

    A committer uses the read set portion of the read-write set for checking the validity of a
    transaction and the write set portion of the read-write set for updating the versions
    and the values of the affected keys.

    In the validation phase, a transaction is considered valid if the version of each key
    present in the read set of the transaction matches the version for the same key in the
    world state - assuming all the preceding valid transactions (including the preceding
    transactions in the same block) are committed (committed-state).

    If a transaction passes the validity check, the committer uses the write set for updating
    the world state. In the update phase, for each key present in the write set, the value in
    the world state for the same key is set to the value as specified in the write set. Further,
    the version of the key in the world state is changed to reflect the latest version.

